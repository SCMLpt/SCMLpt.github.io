<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SciML Playground: Explore & Simulate</title>

  <!-- Plotly.js for advanced plotting -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <style>
    * {
      margin: 0; padding: 0; box-sizing: border-box;
    }
    body {
      font-family: 'Roboto', Arial, sans-serif;
      background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
      color: #e0e1dd;
      min-height: 100vh;
      overflow-x: hidden;
    }
    /* 네비게이션 스타일 */
    nav {
      background: rgba(10, 25, 47, 0.95);
      padding: 15px 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }
    nav a {
      color: #00d4ff; text-decoration: none; margin: 0 20px; font-weight: 600;
      transition: color 0.3s ease;
    }
    nav a:hover, nav a.active {
      color: #ff6f61;
    }
    /* 히어로 섹션 */
    .hero {
      height: 350px;
      background: url('https://via.placeholder.com/1920x350?text=SciML+Universe') no-repeat center/cover;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      color: #fff; font-size: 2.5em; font-weight: bold;
    }
    .hero p {
      font-size: 0.6em; margin-top: 10px; color: #b0c4de;
    }
    /* 컨테이너 스타일 */
    .container {
      width: 85%; margin: 40px auto; padding: 25px;
      background: rgba(27, 38, 59, 0.85);
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
    }
    h1 {
      color: #ffd700; text-align: center; margin-bottom: 20px; font-size: 2.2em;
    }
    .description {
      background: rgba(45, 64, 89, 0.7); padding: 15px; border-radius: 8px;
      color: #b0c4de; line-height: 1.5; margin-bottom: 20px;
    }
    /* 입력 및 버튼 스타일 */
    textarea, input[type="range"] {
      width: 100%; padding: 10px; margin: 10px 0; background: #0d1b2a;
      border: 1px solid #415a77; border-radius: 5px; color: #e0e1dd; font-size: 1.1em;
    }
    button {
      background: linear-gradient(90deg, #ff6f61, #de4d4d);
      color: #fff; border: none; padding: 12px 30px; font-size: 1.1em;
      border-radius: 5px; cursor: pointer; transition: all 0.3s ease;
      margin: 10px 5px;
    }
    button:hover {
      background: linear-gradient(90deg, #ff8a75, #ff6f61);
      transform: scale(1.05);
    }
    /* 플롯 스타일 */
    .plot-div {
      width: 100%; height: 500px; margin: 20px auto; border: 2px solid #415a77;
      border-radius: 5px; background: #0d1b2a;
    }
    .feedback {
      background: rgba(45, 64, 89, 0.7); padding: 15px; border-radius: 5px;
      color: #00d4ff; margin-top: 15px;
    }
    /* 반응형 디자인 */
    @media (max-width: 768px) {
      .container { width: 95%; }
      .hero { height: 250px; font-size: 1.8em; }
      .plot-div { height: 350px; }
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">Home</a>
    <a href="open_research_chat.html">Open Research Chat</a>
    <a href="about_scmlpt.html" class="active">SciML Playground</a>
  </nav>

  <div class="hero">
    SciML Playground
    <p>Explore Scientific Machine Learning in Action</p>
  </div>

  <!-- 1) SciML Boundary Layer Simulation -->
  <div class="container" id="scimlContainer">
    <h1>Boundary Layer Exploration</h1>
    <div class="description">
      <p>Adjust \(\epsilon\) and input known data to solve the PDE: \(-\epsilon \Delta u^\epsilon - u^\epsilon_x = f(x,y)\).</p>
      <p>SciML combines physics-based PDEs with machine learning for fast predictions.</p>
    </div>
    <label for="epsilonSlider">\(\epsilon\): <span id="epsilonValue">0.01</span></label>
    <input type="range" id="epsilonSlider" min="0.001" max="0.1" step="0.001" value="0.01" onchange="updateEpsilon(this.value)">
    <textarea id="scimlUserInput" placeholder='{"known": [[x1, y1, u1], ...], "epsilons": [0.01]}'></textarea>
    <button onclick="scimlSubmitInput()">Run Simulation</button>
    <div class="feedback" id="scimlResultDisplay"></div>
    <div class="plot-div" id="scimlPlotDiv"></div>
  </div>

  <!-- 2) Dynamic Domain Creator -->
  <div class="container" id="domainContainer">
    <h1>Dynamic Domain Simulator</h1>
    <div class="description">
      <p>Define a 4-point polygon domain and watch the time-dependent CDR equation unfold in 3D.</p>
      <p>Click 4 points to create your domain!</p>
    </div>
    <div class="plot-div" id="domainPlot" style="height: 400px;"></div>
    <div class="feedback" id="domainFeedback">No points clicked yet.</div>
    <button onclick="domainClear()">Clear Domain</button>
    <button onclick="domainSubmit()">Simulate</button>
    <div class="feedback" id="domainPredDisplay"></div>
    <div class="plot-div" id="domain3DPlot"></div>
  </div>

  <!-- 3) Static Reaction-Diffusion -->
  <div class="container" id="staticDomainContainer">
    <h1>Static Reaction-Diffusion</h1>
    <div class="description">
      <p>Define a domain and get a static prediction without time evolution.</p>
      <p>Perfect for quick SciML experiments!</p>
    </div>
    <div class="plot-div" id="staticDomainPlot" style="height: 400px;"></div>
    <div class="feedback" id="staticDomainFeedback">No points clicked yet.</div>
    <button onclick="staticDomainClear()">Clear Domain</button>
    <button onclick="staticDomainSubmit()">Predict</button>
    <div class="feedback" id="staticDomainPredDisplay"></div>
    <div class="plot-div" id="staticDomain2DPlot"></div>
  </div>

  <script>
    // 공통 변수 및 초기화
    let domainPoints = [], staticDomainPoints = [];

    // 1) SciML Simulation
    function updateEpsilon(val) {
      document.getElementById('epsilonValue').innerText = val;
    }

    async function scimlSubmitInput() {
      const epsilon = document.getElementById('epsilonSlider').value;
      const inputText = document.getElementById('scimlUserInput').value || '{"known": []}';
      let jsonData;
      try {
        jsonData = JSON.parse(inputText);
        jsonData.epsilons = [parseFloat(epsilon)];
        if (!jsonData.unknown) {
          jsonData.unknown = [Array(100).fill().map((_, i) => [i % 10 * 0.1, Math.floor(i / 10) * 0.1, -1])];
        }
      } catch (e) {
        alert('Invalid JSON!');
        return;
      }

      const response = await fetch('https://b5f9-125-186-24-176.ngrok-free.app/predict', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(jsonData)
      });
      const data = await response.json();
      console.log(data);
      document.getElementById('scimlResultDisplay').innerText = data.error || 'Simulation Complete!';
      if (data.output || data.result) {
        createSciMLPlot(jsonData.unknown[0], data.output || data.result);
      }
    }

    function createSciMLPlot(unknownData, outputData) {
      const X = [], Y = [], Z = [];
      for (let i = 0; i < 10; i++) {
        X.push([]); Y.push([]); Z.push([]);
        for (let j = 0; j < 10; j++) {
          const idx = i * 10 + j;
          X[i][j] = unknownData[idx][0];
          Y[i][j] = unknownData[idx][1];
          Z[i][j] = Array.isArray(outputData[idx]) ? outputData[idx][0] : outputData[idx];
        }
      }
      Plotly.newPlot('scimlPlotDiv', [{
        type: 'surface', x: X, y: Y, z: Z, colorscale: 'Plasma'
      }], {
        title: 'Predicted u(x,y)', scene: { xaxis: { title: 'x' }, yaxis: { title: 'y' }, zaxis: { title: 'u' } }
      });
    }

    // 2) Dynamic Domain Creator
    const domainTrace = { x: [], y: [], mode: 'lines+markers', fill: 'toself', fillcolor: 'rgba(255, 99, 71, 0.3)', line: { color: '#ff6347' } };
    Plotly.newPlot('domainPlot', [domainTrace], { title: 'Define Your Domain', xaxis: { range: [0, 1.5] }, yaxis: { range: [0, 1.5] } })
      .then(gd => gd.addEventListener('mousedown', e => domainClick(e, domainPoints, 'domainPlot', domainUpdateFeedback)));

    function domainClick(evt, points, plotId, updateFn) {
      if (points.length >= 4) return;
      const rect = document.getElementById(plotId).getBoundingClientRect();
      const xAxis = Plotly.d3.select(`#${plotId} .xaxislayer-above`).node();
      const yAxis = Plotly.d3.select(`#${plotId} .yaxislayer-above`).node();
      const x = evt.clientX - rect.left, y = evt.clientY - rect.top;
      const xData = xAxis.p2d(x), yData = yAxis.p2d(y);
      points.push([xData, yData]);
      Plotly.update(plotId, { x: [points.map(p => p[0])], y: [points.map(p => p[1])] }, {}, [0]);
      updateFn();
    }

    function domainUpdateFeedback() {
      document.getElementById('domainFeedback').innerHTML = domainPoints.length ? 
        `Clicked ${domainPoints.length} points:<br>` + domainPoints.map((p, i) => `Point ${i+1}: (${p[0].toFixed(2)}, ${p[1].toFixed(2)})`).join('<br>') : 
        'No points clicked yet.';
    }

    function domainClear() {
      domainPoints = [];
      Plotly.update('domainPlot', { x: [[]], y: [[]] }, {}, [0]);
      domainUpdateFeedback();
      document.getElementById('domain3DPlot').innerHTML = '';
    }

    async function domainSubmit() {
      if (domainPoints.length !== 4) return alert('Select 4 points!');
      const response = await fetch('https://b5f9-125-186-24-176.ngrok-free.app/predict_points', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ points: domainPoints })
      });
      const data = await response.json();
      if (data.plot_points) createTimeLapse3D(data.plot_points);
      document.getElementById('domainPredDisplay').innerText = data.pred ? `Prediction: ${JSON.stringify(data.pred)}` : data.error || '';
    }

    function createTimeLapse3D(plot_points) {
      const times = Object.keys(plot_points).sort((a, b) => a - b);
      const frames = times.map(t => ({
        name: t, data: [{ type: 'scatter3d', x: plot_points[t].map(p => p[0]), y: plot_points[t].map(p => p[1]), z: plot_points[t].map(p => p[2]), 
          mode: 'markers', marker: { size: 5, color: plot_points[t].map(p => p[2]), colorscale: 'Viridis' } }]
      }));
      Plotly.newPlot('domain3DPlot', frames[0].data, {
        title: 'Time Evolution', scene: { xaxis: { title: 'x' }, yaxis: { title: 'y' }, zaxis: { title: 'u' } },
        updatemenus: [{ buttons: [{ label: 'Play', method: 'animate', args: [null, { frame: { duration: 500 } }] }] }],
        sliders: [{ steps: times.map(t => ({ label: t, method: 'animate', args: [[t]] })) }]
      }).then(() => Plotly.addFrames('domain3DPlot', frames));
    }

    // 3) Static Reaction-Diffusion
    const staticTrace = { x: [], y: [], mode: 'lines+markers', fill: 'toself', fillcolor: 'rgba(0, 255, 127, 0.3)', line: { color: '#00ff7f' } };
    Plotly.newPlot('staticDomainPlot', [staticTrace], { title: 'Define Static Domain', xaxis: { range: [1, 2] }, yaxis: { range: [1, 2] } })
      .then(gd => gd.addEventListener('mousedown', e => domainClick(e, staticDomainPoints, 'staticDomainPlot', staticDomainUpdateFeedback)));

    function staticDomainUpdateFeedback() {
      document.getElementById('staticDomainFeedback').innerHTML = staticDomainPoints.length ? 
        `Clicked ${staticDomainPoints.length} points:<br>` + staticDomainPoints.map((p, i) => `Point ${i+1}: (${p[0].toFixed(2)}, ${p[1].toFixed(2)})`).join('<br>') : 
        'No points clicked yet.';
    }

    function staticDomainClear() {
      staticDomainPoints = [];
      Plotly.update('staticDomainPlot', { x: [[]], y: [[]] }, {}, [0]);
      staticDomainUpdateFeedback();
      document.getElementById('staticDomain2DPlot').innerHTML = '';
    }

    async function staticDomainSubmit() {
      if (staticDomainPoints.length !== 4) return alert('Select 4 points!');
      const response = await fetch('https://b5f9-125-186-24-176.ngrok-free.app/predict_no_time', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ points: staticDomainPoints })
      });
      const data = await response.json();
      if (data.plot_points) createStatic2DPlot(data.plot_points);
      document.getElementById('staticDomainPredDisplay').innerText = data.relative_error ? `Relative Error: ${data.relative_error.toFixed(4)}` : data.error || '';
    }

    function createStatic2DPlot(plot_points) {
      Plotly.newPlot('staticDomain2DPlot', [{
        x: plot_points.map(p => p[0]), y: plot_points.map(p => p[1]), mode: 'markers',
        marker: { size: 10, color: plot_points.map(p => p[2]), colorscale: 'Portland', colorbar: { title: 'u(x,y)' } }, type: 'scatter'
      }], { title: 'Static Prediction', xaxis: { title: 'x' }, yaxis: { title: 'y' } });
    }
  </script>
</body>
</html>
